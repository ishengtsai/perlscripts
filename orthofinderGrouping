#!/usr/bin/perl
use strict;
use Data::Dumper;

=caption
This is used to parse grouping result and put seqeuences into seperate fasta files.
=cut
&PrintUsage() if (scalar(@ARGV) != 6);

my $species_file= $ARGV[0];
my $group_file= $ARGV[1];
my $old_fasta_dir= $ARGV[2];
my $out_fasta_dir= $ARGV[3];
my $out_aln_dir= $ARGV[4];
my $cpu= $ARGV[5];
map {mkdir $_;} grep {not -e $_} ($out_fasta_dir,$out_aln_dir);

## read species
open S, "< $species_file" or die;
my @target_species= <S>;
close S;
map {chomp;} @target_species;

## construct sequence library
my %seq_library= ();
opendir D, "$old_fasta_dir" or die;
my @files= grep {/\.[fasta|fa]/} readdir D;
closedir D;
foreach my $file (@files){
    open F, "< $old_fasta_dir/$file" or die;
    my @all= <F>;
    close F;

    my $all_str= join '', @all;
    my @elements= split /\>/, $all_str;
    @elements= grep {/\w/} @elements;
    die "not a fasta file\n" if ($#elements < 0);

    foreach my $element (@elements){
	my @d= split /\n/, $element;
	@d= grep {/\S+/,} @d;
	my $title= shift @d;
	my $seq= join '', @d;
	$seq_library{$title}= $seq;
    }
}

## identify single copy orthogroups
my %members_id= ();
open G, "< $group_file" or die;
while (my $line=<G>){
    chomp $line;
    my @d= split /\s+/,  $line;
    my $group= shift @d;
    $group=~s/OG0+//;
    $group=~s/\W//g;
    
    my @species= $line=~/([^\s\|]+)\|/g;
    my %count= ();
    map {$count{$_}=0;} @species;
    map {$count{$_}+=1;} @species;
    if (&DetectSingleCopy(\%count, \@target_species)){
        my @members= $line=~/([^\s\|]+\|[^\s\|]+)/g;
	my $new_fasta= "$out_fasta_dir/$group.fasta";
	my $new_aln= "$out_aln_dir/$group.aln";
	foreach my $member (@members){
	  my @d= split /\|/, $member;
	  my $sp= $d[0];
	  &PrintFasta($sp, $seq_library{$member}, $new_fasta, 0);
	}
#	map {&PrintFasta($_, $seq_library{$_}, $new_fasta, 0)} @members;
#	system "mafft --thread 32 --quiet --maxiterate 1000 $new_fasta > $new_aln";
	system "mafft --thread $cpu --quiet --maxiterate 1000 $new_fasta > $new_aln";
    }
}
close G;



sub DetectSingleCopy {
    my ($count, $required_species)= @_;
    my $result= 1;
    my @values= ();
    map {$result= 0;} grep {(not exists $count->{$_})||($count->{$_} != 1)} @{$required_species};

    return $result;
}

sub PrintFasta {
    my ($title, $seq, $file, $overwrite)= @_;
    chomp $title;
    chomp $seq;

    if ($overwrite == 1){
	open A, "> $file" or die;
    }
    else{
	open A, ">> $file" or die;
    }

    print A ">$title\n";
    my $l= length($seq);
    for my $i (0..$l-1){
	print A substr($seq, $i, 1);
	print A "\n" if (($i % 60 == 59) || ($i == $l-1));
    }
    close A;
}

sub PrintUsage {
    die "usage: orthofinderGrouping species_file group_file original_fasta_folder output_fasta_folder output_alignment_folder max_cpu_num
  - species_file: the file listing species
  - group_file: the file listing grouping results 
	(OrthologousGroups.txt generated by Orthofinder, or outputs of other software that use the same format)
  - original_fasta_folder: the folder of fasta files used as the input of orthofinder
  - output_fasta_folder: where you want fasta files of each single-copy orthogroup can be put
  - output_alignment_folder: where you want alignment files of each single-copy orthogroup can be put
  - max_cpu_num: the number of cpu that can be used for computing alignments";
}
